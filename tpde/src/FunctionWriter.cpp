// SPDX-FileCopyrightText: 2025 Contributors to TPDE <https://tpde.org>
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include "tpde/FunctionWriter.hpp"

#include "tpde/Assembler.hpp"
#include "tpde/DWARF.hpp"
#include "tpde/util/VectorWriter.hpp"

namespace tpde {

void FunctionWriterBase::begin_module(Assembler &assembler) noexcept {
  this->assembler = &assembler;
  eh_frame_section = &assembler.get_section(
      assembler.get_default_section(SectionKind::EHFrame));
  eh_writer = util::VectorWriter(eh_frame_section->data);
  cur_personality_func_addr = SymRef{};
  eh_init_cie();
}

void FunctionWriterBase::end_module() noexcept {
  // The last FDE must align to 8 bytes, as other eh_frame sections, not
  // generated by us, might require a larger alignment.
  assert(eh_writer.size() % 4 == 0 && "unaligned eh_frame section");
  if (eh_writer.size() & 7) {
    assert(eh_writer.size() % 8 == 4);
    // Increase size of CIE/FDE, padded with CFA_nop instructions.
    eh_writer.zero(4);
    *reinterpret_cast<u32 *>(eh_writer.data() + fde_start) += 4;
  }
  eh_writer.flush();
}

void FunctionWriterBase::begin_func() noexcept {
  func_begin = offset();
  reloc_begin = section->reloc_count();

  label_offsets.clear();
  label_skew = 0;
  label_fixups.clear();

  jump_table_alloc.reset();
  jump_tables.clear();

  except_call_site_table.clear();
  except_action_table.clear();
  except_type_info_table.clear();
  except_spec_table.clear();
  except_action_table.resize(2); // cleanup entry
}

void FunctionWriterBase::remove_prologue_bytes(u32 start, u32 size) noexcept {
  assert(start >= func_begin);
  assert(start + size <= offset());
  // This should work, but is not tested.
  assert(label_skew == 0 && "multiple calls to remove_bytes unsupported");
  for ([[maybe_unused]] u32 label_offset : label_offsets) {
    assert(label_offset - label_skew >= start + size &&
           "label in function prologue?");
  }

  if (size == 0) {
    return;
  }

  size_t move_len = offset() - (start + size);
  std::memmove(data_begin + start, data_begin + start + size, move_len);
  section->adjust_relocation_offsets(reloc_begin, size);
  data_cur -= size;
  label_skew += size;
}

FunctionWriterBase::JumpTable &
    FunctionWriterBase::alloc_jump_table(u32 size, Reg idx, Reg tmp) noexcept {
  size_t alloc_size = sizeof(JumpTable) + size * sizeof(Label);
  auto *buf = jump_table_alloc.allocate(alloc_size, alignof(JumpTable));
  JumpTable *jt = new (reinterpret_cast<JumpTable *>(buf)) JumpTable{
      .size = size,
      .off = static_cast<u32>(offset()),
      .idx = idx,
      .tmp = tmp,
  };
  jump_tables.push_back(jt);
  return *jt;
}

void FunctionWriterBase::eh_align_frame() noexcept {
  // We use PC-relative 32-bit encodings, therefore a 4-byte alignment is
  // sufficient within the section.
  if (unsigned count = -eh_writer.size() & 3) {
    eh_writer.reserve(4);
    // Small hack for performance: always write 4 bytes (single instruction, no
    // loop in machine code), but adjust pointer only by count bytes.
    for (unsigned i = 0; i < 4; ++i) {
      eh_writer.write_unchecked<u8>(dwarf::DW_CFA_nop);
    }
    eh_writer.unskip(4 - count);
  }
}

void FunctionWriterBase::eh_write_inst(const u8 opcode,
                                       const u64 arg) noexcept {
  if ((opcode & dwarf::DWARF_CFI_PRIMARY_OPCODE_MASK) != 0) {
    assert((arg & dwarf::DWARF_CFI_PRIMARY_OPCODE_MASK) == 0);
    eh_writer.write<u8>(opcode | arg);
  } else {
    eh_writer.reserve(11);
    eh_writer.write_unchecked<u8>(opcode);
    eh_writer.write_uleb_unchecked(arg);
  }
}

void FunctionWriterBase::eh_write_inst(const u8 opcode,
                                       const u64 first_arg,
                                       const u64 second_arg) noexcept {
  eh_write_inst(opcode, first_arg);
  eh_writer.write_uleb(second_arg);
}

void FunctionWriterBase::eh_advance_raw(u64 size_units) noexcept {
  if (size_units < 0x40) {
    eh_writer.write<u8>(dwarf::DW_CFA_advance_loc | size_units);
  } else if (size_units <= UINT8_MAX) {
    eh_writer.write<u8>(dwarf::DW_CFA_advance_loc1);
    eh_writer.write<u8>(size_units);
  } else if (size_units <= UINT16_MAX) {
    eh_writer.write<u8>(dwarf::DW_CFA_advance_loc2);
    eh_writer.write<u16>(size_units);
  } else if (size_units <= UINT32_MAX) {
    eh_writer.write<u8>(dwarf::DW_CFA_advance_loc4);
    eh_writer.write<u32>(size_units);
  } else {
    TPDE_UNREACHABLE("CFI advance beyond 32 bits");
  }
}

void FunctionWriterBase::eh_init_cie(SymRef personality_func_addr) noexcept {
  // write out the initial CIE

  // CIE layout:
  // length: u32
  // id: u32
  // version: u8
  // augmentation: 3 or 5 bytes depending on whether the CIE has a personality
  // function
  // code_alignment_factor: uleb128 (but we only use 1 byte)
  // data_alignment_factor: sleb128 (but we only use 1 byte)
  // return_addr_register: u8
  // augmentation_data_len: uleb128 (but we only use 1 byte)
  // augmentation_data:
  //   if personality:
  //     personality_encoding: u8
  //     personality_addr: u32
  //     lsa_encoding: u8
  //   fde_ptr_encoding: u8
  // instructions: [u8]
  //
  // total: 17 bytes or 25 bytes

  auto off = eh_writer.size();
  assert(off % 4 == 0 && "eh_frame section unaligned");
  eh_cur_cie_off = off;
  // fde_start always points to the start of the last record in the section.
  fde_start = off;

  eh_writer.reserve(32 + cie_info.instrs.size());

  eh_writer.skip_unchecked(4);       // length written at the end.
  eh_writer.write_unchecked<u32>(0); // id is 0 for CIEs
  eh_writer.write_unchecked<u8>(1);  // version
  if (!personality_func_addr.valid()) {
    // augmentation is "zR" for a CIE with no personality meaning there is
    // the augmentation_data_len and ptr_size field
    eh_writer.write_unchecked<u8>('z');
    eh_writer.write_unchecked<u8>('R');
  } else {
    // with a personality function the augmentation is "zPLR" meaning there
    // is augmentation_data_len, personality_encoding, personality_addr,
    // lsa_encoding and ptr_size
    eh_writer.write_unchecked<u8>('z');
    eh_writer.write_unchecked<u8>('P');
    eh_writer.write_unchecked<u8>('L');
    eh_writer.write_unchecked<u8>('R');
  }
  eh_writer.write_unchecked<u8>(0);

  eh_writer.write_unchecked<u8>(cie_info.code_alignment_factor);
  eh_writer.write_unchecked<u8>(cie_info.data_alignment_factor);

  // return_addr_register is defined by the derived impl
  eh_writer.write_unchecked<u8>(cie_info.return_addr_register);

  // augmentation_data_len is 1 when no personality is present or 7 otherwise
  eh_writer.write_unchecked<u8>((!personality_func_addr.valid()) ? 1 : 7);

  if (personality_func_addr.valid()) {
    // the personality encoding is a 4-byte pc-relative address where the
    // address of the personality func is stored
    eh_writer.write_unchecked<u8>(dwarf::DW_EH_PE_pcrel |
                                  dwarf::DW_EH_PE_sdata4 |
                                  dwarf::DW_EH_PE_indirect);

    assembler->reloc_pc32(eh_frame_section->get_ref(),
                          personality_func_addr,
                          eh_writer.size(),
                          0);
    eh_writer.write_unchecked<u32>(
        0); // relocated, zero for deterministic output

    // the lsa_encoding as a 4-byte pc-relative address since the whole
    // object should fit in 2gb
    eh_writer.write_unchecked<u8>(dwarf::DW_EH_PE_pcrel |
                                  dwarf::DW_EH_PE_sdata4);
  }

  // fde_ptr_encoding is a 4-byte signed pc-relative address
  eh_writer.write_unchecked<u8>(dwarf::DW_EH_PE_sdata4 | dwarf::DW_EH_PE_pcrel);

  eh_writer.write_unchecked(cie_info.instrs);

  eh_align_frame();

  // patch size of CIE (length is not counted)
  u32 size = eh_writer.size() - off - sizeof(u32);
  std::memcpy(eh_writer.data() + off, &size, sizeof(size));
}

void FunctionWriterBase::eh_begin_fde(SymRef personality_func_addr) noexcept {
  if (personality_func_addr != cur_personality_func_addr) {
    eh_init_cie(personality_func_addr);
    cur_personality_func_addr = personality_func_addr;
  }

  fde_start = eh_writer.size();
  assert(fde_start % 4 == 0 && "eh_frame section unaligned");

  // FDE Layout:
  //  length: u32
  //  id: u32
  //  func_start: i32
  //  func_size: i32
  // augmentation_data_len: uleb128 (but we only use 1 byte)
  // augmentation_data:
  //   if personality:
  //     lsda_ptr: i32 (we use a 4 byte signed pc-relative pointer to an
  //     absolute address)
  // instructions: [u8]
  //
  // Total Size: 17 bytes or 21 bytes

  eh_writer.zero(!cur_personality_func_addr.valid() ? 17 : 21);
  u8 *data = eh_writer.data() + fde_start;

  // we encode length later

  // id is the offset from the current CIE to the id field
  *reinterpret_cast<u32 *>(data + 4) = fde_start - eh_cur_cie_off + sizeof(u32);

  // func_start and func_size will be relocated at the end

  // augmentation_data_len is 0 with no personality or 4 otherwise
  if (cur_personality_func_addr.valid()) {
    data[16] = 4;
  }
}

void FunctionWriterBase::eh_end_fde() noexcept {
  eh_align_frame();

  u8 *eh_data = eh_writer.data();

  // relocate the func_start to the function
  // relocate against .text so we don't have to fix up any relocations
  // NB: ld.bfd (for a reason that needs to be investigated) doesn't accept
  // using the function symbol here.
  assembler->reloc_pc32(eh_frame_section->get_ref(),
                        assembler->section_symbol(section->get_ref()),
                        fde_start + 8,
                        func_begin);
  // Adjust func_size to the function size
  *reinterpret_cast<i32 *>(eh_data + fde_start + 12) = offset() - func_begin;

  const u32 len = eh_writer.size() - fde_start - sizeof(u32);
  *reinterpret_cast<u32 *>(eh_data + fde_start) = len;
}

void FunctionWriterBase::except_encode_func() noexcept {
  if (!cur_personality_func_addr.valid()) {
    return;
  }

  // encode the call sites first, otherwise we can't write the header
  {
    util::VectorWriter ecst_writer(except_encoded_call_sites, 0);
    ecst_writer.reserve(16 * except_call_site_table.size() + 40);

    u64 fn_end = offset();
    u64 cur = func_begin;
    for (auto &info : except_call_site_table) {
      ecst_writer.reserve(80);

      u64 start = info.start - label_skew;
      if (start > cur) {
        // Encode padding entry
        ecst_writer.write_uleb_unchecked(cur - func_begin);
        ecst_writer.write_uleb_unchecked(start - cur);
        ecst_writer.write_uleb_unchecked(0);
        ecst_writer.write_uleb_unchecked(0);
      }
      ecst_writer.write_uleb_unchecked(start - func_begin);
      ecst_writer.write_uleb_unchecked(info.len);
      u64 fn_off = label_offset(info.landing_pad) - func_begin;
      assert(fn_off < (fn_end - func_begin));
      ecst_writer.write_uleb_unchecked(fn_off);
      ecst_writer.write_uleb_unchecked(info.action_entry);
      cur = start + info.len;
    }
    if (cur < fn_end) {
      // Add padding until the end of the function
      ecst_writer.write_uleb_unchecked(cur - func_begin);
      ecst_writer.write_uleb_unchecked(fn_end - cur);
      ecst_writer.write_uleb_unchecked(0);
      ecst_writer.write_uleb_unchecked(0);
    }

    // zero-terminate
    ecst_writer.write_unchecked<u8>(0);
    ecst_writer.write_unchecked<u8>(0);
  }

  // TODO: if the text section is part of a section group, this should go into
  // the LSDA section of that group.
  SecRef secref_lsda = assembler->get_default_section(SectionKind::LSDA);
  DataSection &sec_lsda = assembler->get_section(secref_lsda);
  size_t lsda_start = sec_lsda.size();

  {
    util::VectorWriter et_writer(sec_lsda.data);
    // write the lsda (see
    // https://github.com/llvm/llvm-project/blob/main/libcxxabi/src/cxa_personality.cpp#L60)
    et_writer.write<u8>(dwarf::DW_EH_PE_omit); // lpStartEncoding
    if (except_action_table.empty()) {
      assert(except_type_info_table.empty());
      // we don't need the type_info table if there is no action entry
      et_writer.write<u8>(dwarf::DW_EH_PE_omit); // ttypeEncoding
    } else {
      et_writer.write<u8>(dwarf::DW_EH_PE_sdata4 | dwarf::DW_EH_PE_pcrel |
                          dwarf::DW_EH_PE_indirect); // ttypeEncoding
      uint64_t classInfoOff =
          (except_type_info_table.size() + 1) * sizeof(uint32_t);
      classInfoOff += except_action_table.size();
      classInfoOff += except_encoded_call_sites.size() +
                      util::uleb_len(except_encoded_call_sites.size()) + 1;
      et_writer.write_uleb(classInfoOff);
    }

    et_writer.write<u8>(dwarf::DW_EH_PE_uleb128); // callSiteEncoding
    et_writer.write_uleb(
        except_encoded_call_sites.size()); // callSiteTableLength
    et_writer.write(except_encoded_call_sites);
    et_writer.write(except_action_table);

    if (!except_action_table.empty()) {
      // allocate space for type_info table
      et_writer.zero((except_type_info_table.size() + 1) * sizeof(u32));

      // in reverse order since indices are negative
      size_t off = et_writer.size() - sizeof(u32) * 2;
      for (auto sym : except_type_info_table) {
        assembler->reloc_pc32(secref_lsda, sym, off, 0);
        off -= sizeof(u32);
      }

      et_writer.write(except_spec_table);
    }
  }

  assembler->reloc_pc32(eh_frame_section->get_ref(),
                        assembler->section_symbol(secref_lsda),
                        fde_start + 17,
                        lsda_start);
}

void FunctionWriterBase::except_add_call_site(const u32 text_off,
                                              const u32 len,
                                              const Label landing_pad,
                                              const bool is_cleanup) noexcept {
  except_call_site_table.push_back(ExceptCallSiteInfo{
      .start = text_off,
      .len = len,
      .landing_pad = landing_pad,
      .action_entry =
          (is_cleanup ? 0 : static_cast<u32>(except_action_table.size()) + 1),
  });
}

void FunctionWriterBase::except_add_cleanup_action() noexcept {
  // pop back the action offset
  except_action_table.pop_back();
  i64 offset = -static_cast<i64>(except_action_table.size());
  util::VectorWriter(except_action_table).write_sleb(offset);
}

void FunctionWriterBase::except_add_action(const bool first_action,
                                           const SymRef type_sym) noexcept {
  if (!first_action) {
    except_action_table.back() = 1;
  }

  auto idx = 0u;
  if (type_sym.valid()) {
    auto found = false;
    for (const auto &sym : except_type_info_table) {
      ++idx;
      if (sym == type_sym) {
        found = true;
        break;
      }
    }
    if (!found) {
      ++idx;
      except_type_info_table.push_back(type_sym);
    }
  }

  util::VectorWriter(except_action_table).write_sleb(idx + 1);
  except_action_table.push_back(0);
}

void FunctionWriterBase::except_add_empty_spec_action(
    const bool first_action) noexcept {
  if (!first_action) {
    except_action_table.back() = 1;
  }

  if (except_spec_table.empty()) {
    except_spec_table.resize(4);
  }

  except_action_table.push_back(127); // SLEB -1
  except_action_table.push_back(0);
}

u32 FunctionWriterBase::except_type_idx_for_sym(const SymRef sym) noexcept {
  // to explain the indexing
  // a ttypeIndex of 0 is reserved for a cleanup action so the type table
  // starts at 1 but the first entry in the type table is reserved for the 0
  // pointer used for catch(...) meaning we start at 2
  auto idx = 2u;
  for (const auto type_sym : except_type_info_table) {
    if (type_sym == sym) {
      return idx;
    }
    ++idx;
  }
  assert(0);
  return idx;
}

void FunctionWriterBase::more_space(size_t size) noexcept {
  size_t cur_size = section->data.size();
  size_t new_size;
  if (cur_size + size <= section->data.capacity()) {
    new_size = section->data.capacity();
  } else {
    new_size = cur_size + (size <= growth_size ? growth_size : size);

    // Grow by factor 1.5
    growth_size = growth_size + (growth_size >> 1);
    // Max 16 MiB per grow.
    growth_size = growth_size < 0x1000000 ? growth_size : 0x1000000;
  }

  const size_t off = offset();
  section->data.resize_uninitialized(new_size);
#ifndef NDEBUG
  thread_local uint8_t rand = 1;
  std::memset(section->data.data() + off, rand += 2, new_size - off);
  section->locked = true;
#endif

  data_begin = section->data.data();
  data_cur = data_begin + off;
  data_reserve_end = data_begin + section->data.size();
}

} // end namespace tpde
